using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

namespace CariocaRuntime
{
    public sealed class GameTableControllerV2 : MonoBehaviour
    {
        [Header("UI (auto) — piles/hand")]
        [SerializeField] private Button deckButton;
        [SerializeField] private Button discardButton;
        [SerializeField] private Transform handLayout;
        [SerializeField] private GameObject cardPrefab;

        [Header("UI (auto) — bank/actions")]
        [SerializeField] private Transform bankLayout;
        [SerializeField] private Button dropButton;
        [SerializeField] private Button addButton;
        [SerializeField] private Button sortButton;

        private readonly List<Card> _hand = new();
        private readonly List<Card> _discard = new();
        private readonly List<BankGroup> _bank = new();

        // ✅ FIX: selección por CARTA (no por índice)
        private readonly HashSet<Card> _selectedCards = new();

        private Deck _deck;
        private bool _hasDrawnThisTurn;

        private void Start()
        {
            if (!AllRefsOk())
            {
                Debug.LogError("GameTableControllerV2: referencias UI incompletas. Recorre el menú Tools → CARIOCA → Upgrade GameTable.");
                enabled = false;
                return;
            }

            deckButton.onClick.RemoveAllListeners();
            discardButton.onClick.RemoveAllListeners();
            deckButton.onClick.AddListener(DrawFromDeck);
            discardButton.onClick.AddListener(DrawFromDiscard);

            dropButton.onClick.RemoveAllListeners();
            addButton.onClick.RemoveAllListeners();
            sortButton.onClick.RemoveAllListeners();

            dropButton.onClick.AddListener(OnDropPressed);
            addButton.onClick.AddListener(OnAddPressed);
            sortButton.onClick.AddListener(() =>
            {
                SortHand();
                RefreshHandUI();
            });

            NewRound();
        }

        private bool AllRefsOk()
        {
            return deckButton && discardButton && handLayout && cardPrefab && bankLayout && dropButton && addButton && sortButton;
        }

        private void NewRound()
        {
            _deck = new Deck();
            _deck.Build54With2Jokers();
            _deck.Shuffle();

            _hand.Clear();
            _discard.Clear();
            _bank.Clear();
            _selectedCards.Clear();

            ClearChildren(handLayout);
            ClearChildren(bankLayout);

            // Deal 12
            for (int i = 0; i < 12; i++)
                _hand.Add(_deck.Draw());

            // First discard cannot be Joker
            Card first = _deck.Draw();
            int safety = 0;
            var temp = new List<Card>();
            while (first.IsJoker && safety < 200)
            {
                temp.Add(first);
                first = _deck.Draw();
                safety++;
            }
            if (temp.Count > 0)
            {
                _deck.AddRange(temp);
                _deck.Shuffle();
            }

            _discard.Add(first);
            _hasDrawnThisTurn = false;

            RefreshDiscardLabel();
            RefreshBankUI();
            RefreshHandUI();
        }

        // ---------- Turn actions ----------
        private void DrawFromDeck()
        {
            if (_hasDrawnThisTurn) return;

            EnsureDeckHasCards();
            var c = _deck.Draw();
            _hand.Add(c);

            _hasDrawnThisTurn = true;

            // (opcional) puedes dejar selección como está o limpiarla
            // _selectedCards.Clear();

            RefreshHandUI();
        }

        private void DrawFromDiscard()
        {
            if (_hasDrawnThisTurn) return;
            if (_discard.Count == 0) return;

            var top = _discard[^1];
            _discard.RemoveAt(_discard.Count - 1);
            _hand.Add(top);

            _hasDrawnThisTurn = true;

            RefreshDiscardLabel();
            RefreshHandUI();
        }

        // ✅ FIX: click toggles selection por CARTA
        private void OnCardClicked(Card card, CardView view)
        {
            if (_selectedCards.Contains(card)) _selectedCards.Remove(card);
            else _selectedCards.Add(card);

            view.SetSelected(_selectedCards.Contains(card));
        }

        private void OnDropPressed()
        {
            if (_selectedCards.Count == 0)
                return;

            // ✅ FIX: selectedCards ya es estable (no depende de índices)
            var selectedCards = _selectedCards.ToList();

            // Validar como Trío o Escala
            string reason;

            if (RulesValidator.TryAsTrio(selectedCards, out reason))
            {
                _bank.Add(new BankGroup(BankGroupType.Trio, selectedCards));
                RemoveSelectedFromHand();
                Debug.Log("✅ Bajaste un TRÍO.");
            }
            else
            {
                List<int> resolved;
                if (RulesValidator.TryAsRun(selectedCards, out reason, out resolved))
                {
                    _bank.Add(new BankGroup(BankGroupType.Run, selectedCards));
                    RemoveSelectedFromHand();
                    Debug.Log("✅ Bajaste una ESCALA.");
                }
                else
                {
                    Debug.LogWarning("❌ No válido para bajar: " + reason);
                    return;
                }
            }

            _selectedCards.Clear();
            RefreshBankUI();
            RefreshHandUI();
        }

        private void OnAddPressed()
        {
            // Para agregar a banca, debe ser exactamente 1 carta seleccionada
            if (_selectedCards.Count != 1)
            {
                Debug.LogWarning("Selecciona EXACTAMENTE 1 carta para agregar a banca.");
                return;
            }

            // Si aún no bajaste nada, no hay banca para agregar
            if (_bank.Count == 0)
            {
                Debug.LogWarning("No hay banca aún. Primero baja un TRÍO o una ESCALA con DROP.");
                return;
            }

            var card = _selectedCards.First();

            // Seguridad: si por alguna razón esa carta ya no está en mano
            if (!_hand.Contains(card))
            {
                Debug.LogWarning("Esa carta ya no está en tu mano (selección antigua).");
                _selectedCards.Clear();
                RefreshHandUI();
                return;
            }

            // Try add to first compatible group (simple MVP)
            for (int g = 0; g < _bank.Count; g++)
            {
                var group = _bank[g];
                string reason;

                bool ok = group.Type == BankGroupType.Trio
                    ? RulesValidator.TryAddToTrio(group, card, out reason)
                    : RulesValidator.TryAddToRun(group, card, out reason);

                if (ok)
                {
                    group.Cards.Add(card);
                    _hand.Remove(card);

                    _selectedCards.Clear();

                    Debug.Log($"✅ Agregaste carta a {(group.Type == BankGroupType.Trio ? "TRÍO" : "ESCALA")}.");
                    RefreshBankUI();
                    RefreshHandUI();
                    return;
                }
            }

            Debug.LogWarning("❌ No pude agregar esa carta a ninguna banca (por reglas).");
        }

        private void RemoveSelectedFromHand()
        {
            // ✅ FIX: remover por CARTA, no por índice
            foreach (var c in _selectedCards)
                _hand.Remove(c);
        }

        private void SortHand()
        {
            // Simple sort: Joker last, then by suit then rank
            _hand.Sort((a, b) =>
            {
                if (a.IsJoker && !b.IsJoker) return 1;
                if (!a.IsJoker && b.IsJoker) return -1;
                if (a.IsJoker && b.IsJoker) return 0;

                int suit = a.Suit.Value.CompareTo(b.Suit.Value);
                if (suit != 0) return suit;

                return ((int)a.Rank).CompareTo((int)b.Rank);
            });

            // como el orden cambió, igual la selección sigue válida (por carta)
            RefreshHandUI();
        }

        // ---------- Deck recycle ----------
        private void EnsureDeckHasCards()
        {
            if (_deck.Count > 0) return;
            if (_discard.Count <= 1) return;

            var top = _discard[^1];
            var recycle = _discard.GetRange(0, _discard.Count - 1);

            _discard.Clear();
            _discard.Add(top);

            _deck.AddRange(recycle);
            _deck.Shuffle();

            Debug.Log("♻️ Mazo vacío: se revuelve descarte y se reutiliza como mazo (dejando 1 arriba).");
        }

        // ---------- UI Refresh ----------
        private void RefreshHandUI()
        {
            ClearChildren(handLayout);

            for (int i = 0; i < _hand.Count; i++)
            {
                var c = _hand[i];
                var go = Instantiate(cardPrefab, handLayout);
                var view = go.GetComponent<CardView>();

                bool selected = _selectedCards.Contains(c);

                // ✅ FIX: pasamos la CARTA al click, no el índice
                view.Bind(c, (v) => OnCardClicked(c, v), selected);
            }
        }

        private void RefreshBankUI()
        {
            ClearChildren(bankLayout);

            for (int g = 0; g < _bank.Count; g++)
            {
                var group = _bank[g];

                var panel = new GameObject($"Group_{g}", typeof(RectTransform), typeof(Image), typeof(VerticalLayoutGroup));
                panel.transform.SetParent(bankLayout, false);

                var img = panel.GetComponent<Image>();
                img.color = new Color(1, 1, 1, 0.10f);

                var vlg = panel.GetComponent<VerticalLayoutGroup>();
                vlg.spacing = 6;
                vlg.childAlignment = TextAnchor.UpperCenter;
                vlg.padding = new RectOffset(10, 10, 10, 10);

                panel.AddComponentInChildrenTMP($"{(group.Type == BankGroupType.Trio ? "TRÍO" : "ESCALA")} (J:{group.JokerCount()})", 18);

                var row = new GameObject("Cards", typeof(RectTransform), typeof(HorizontalLayoutGroup));
                row.transform.SetParent(panel.transform, false);
                var h = row.GetComponent<HorizontalLayoutGroup>();
                h.spacing = 8;
                h.childAlignment = TextAnchor.MiddleCenter;

                foreach (var c in group.Cards)
                {
                    var mini = Instantiate(cardPrefab, row.transform);
                    var rt = mini.GetComponent<RectTransform>();
                    rt.sizeDelta = new Vector2(80, 110);

                    var view = mini.GetComponent<CardView>();
                    view.Bind(c, null, false); // no click in bank MVP
                }
            }
        }

        private void RefreshDiscardLabel()
        {
            var tmp = discardButton.GetComponentInChildren<TextMeshProUGUI>(true);
            if (tmp == null) return;

            if (_discard.Count == 0) tmp.text = "DESCARTE";
            else
            {
                var top = _discard[^1];
                tmp.text = top.IsJoker ? "DESCARTE\n(JOKER)" : "DESCARTE\n(" + top.ToString() + ")";
            }
        }

        private static void ClearChildren(Transform t)
        {
            for (int i = t.childCount - 1; i >= 0; i--)
                Object.Destroy(t.GetChild(i).gameObject);
        }
    }

    internal static class TMPHelpers
    {
        public static TextMeshProUGUI AddComponentInChildrenTMP(this GameObject parent, string text, int size)
        {
            var go = new GameObject("TMP", typeof(RectTransform));
            go.transform.SetParent(parent.transform, false);
            var tmp = go.AddComponent<TextMeshProUGUI>();
            tmp.text = text;
            tmp.fontSize = size;
            tmp.alignment = TextAlignmentOptions.Center;
            tmp.color = new Color(1, 1, 1, 0.9f);
            return tmp;
        }
    }
}
