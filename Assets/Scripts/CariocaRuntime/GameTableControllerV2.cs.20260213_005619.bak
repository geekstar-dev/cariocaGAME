using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

namespace CariocaRuntime
{
    public sealed class GameTableControllerV2 : MonoBehaviour
    {
        [Header("UI — piles/hand")]
        [SerializeField] private Button deckButton;
        [SerializeField] private Button discardButton;
        [SerializeField] private Transform handLayout;
        [SerializeField] private GameObject cardPrefab;

        [Header("UI — bank/actions")]
        [SerializeField] private Transform bankLayout;
        [SerializeField] private Button dropButton; // BAJAR
        [SerializeField] private Button addButton;  // lo usaremos como DESCARTAR (1)
        [SerializeField] private Button sortButton;

        [Header("UI (optional) — labels")]
        [SerializeField] private TextMeshProUGUI roundLabel;

        private readonly List<Card> _hand = new();
        private readonly List<Card> _discard = new();
        private readonly List<BankGroup> _bank = new();
        private readonly HashSet<int> _selectedHandIndices = new();

        private Deck _deck;
        private bool _hasDrawnThisTurn;

        private void Start()
        {
            if (!AllRefsOk())
            {
                Debug.LogError("GameTableControllerV2: faltan referencias UI (deck/discard/handLayout/cardPrefab/bank/buttons).");
                enabled = false;
                return;
            }

            deckButton.onClick.RemoveAllListeners();
            discardButton.onClick.RemoveAllListeners();
            deckButton.onClick.AddListener(DrawFromDeck);
            discardButton.onClick.AddListener(DrawFromDiscard);

            dropButton.onClick.RemoveAllListeners();
            addButton.onClick.RemoveAllListeners();
            sortButton.onClick.RemoveAllListeners();

            dropButton.onClick.AddListener(OnDropPressed);
            addButton.onClick.AddListener(DiscardSelectedOne);
            sortButton.onClick.AddListener(() => { SmartSort(); RefreshHandUI(); });

            NewRound();
        }

        private void Update()
        {
            // Drag&Drop handler
            if (CariocaDragBus.LastDrop.HasValue)
            {
                var info = CariocaDragBus.LastDrop.Value;
                CariocaDragBus.Clear();

                if (info.view == null || info.zone == null) return;

                if (info.zone.zoneType == DropZone.ZoneType.Discard)
                {
                    SelectOnlyCard(info.view.Card);
                    DiscardSelectedOne();
                }
                else
                {
                    // MVP: for now, bank drop = same as pressing BAJAR
                    if (_selectedHandIndices.Count == 0)
                        SelectOnlyCard(info.view.Card);

                    OnDropPressed();
                }
            }

            // Show BAJAR only if selection forms a valid group
            if (dropButton != null)
                dropButton.gameObject.SetActive(CanDropSelection());
        }

        private bool AllRefsOk()
        {
            return deckButton && discardButton && handLayout && cardPrefab && bankLayout && dropButton && addButton && sortButton;
        }

        private void NewRound()
        {
            _deck = new Deck();
            _deck.Build54With2Jokers();
            _deck.Shuffle();

            _hand.Clear();
            _discard.Clear();
            _bank.Clear();
            _selectedHandIndices.Clear();

            ClearChildren(handLayout);
            ClearChildren(bankLayout);

            for (int i = 0; i < 12; i++)
                _hand.Add(_deck.Draw());

            // First discard cannot be Joker
            Card first = _deck.Draw();
            int safety = 0;
            var temp = new List<Card>();
            while (first.IsJoker && safety < 200)
            {
                temp.Add(first);
                first = _deck.Draw();
                safety++;
            }
            if (temp.Count > 0)
            {
                _deck.AddRange(temp);
                _deck.Shuffle();
            }

            _discard.Add(first);
            _hasDrawnThisTurn = false;

            if (roundLabel) roundLabel.text = "Ronda 1 (MVP)";

            RefreshDiscardLabel();
            RefreshBankUI();
            RefreshHandUI();
        }

        private void DrawFromDeck()
        {
            if (_hasDrawnThisTurn) return;
            EnsureDeckHasCards();
            _hand.Add(_deck.Draw());
            _hasDrawnThisTurn = true;
            RefreshHandUI();
        }

        private void DrawFromDiscard()
        {
            if (_hasDrawnThisTurn) return;
            if (_discard.Count == 0) return;

            var top = _discard[^1];
            _discard.RemoveAt(_discard.Count - 1);
            _hand.Add(top);

            _hasDrawnThisTurn = true;
            RefreshDiscardLabel();
            RefreshHandUI();
        }

        private void OnCardClicked(int index, CardView view)
        {
            if (_selectedHandIndices.Contains(index)) _selectedHandIndices.Remove(index);
            else _selectedHandIndices.Add(index);

            view.SetSelected(_selectedHandIndices.Contains(index));
        }

        private void SelectOnlyCard(Card card)
        {
            _selectedHandIndices.Clear();
            int idx = _hand.FindIndex(c => c.Rank == card.Rank && c.Suit == card.Suit);
            if (idx >= 0) _selectedHandIndices.Add(idx);
        }

        private void DiscardSelectedOne()
        {
            if (!_hasDrawnThisTurn)
            {
                Debug.LogWarning("Primero roba (MAZO o DESCARTE). Luego descarta 1.");
                return;
            }

            var selected = GetSelectedCardsSafe();
            if (selected.Count != 1)
            {
                Debug.LogWarning("Selecciona EXACTAMENTE 1 carta para DESCARTAR.");
                return;
            }

            // Remove that card
            var c = selected[0];
            int idx = _hand.FindIndex(x => x.Rank == c.Rank && x.Suit == c.Suit);
            if (idx < 0) return;

            _hand.RemoveAt(idx);
            _discard.Add(c);

            _hasDrawnThisTurn = false;
            _selectedHandIndices.Clear();

            RefreshDiscardLabel();
            RefreshHandUI();
        }

        private void OnDropPressed()
        {
            var selectedCards = GetSelectedCardsSafe();
            if (selectedCards.Count == 0) return;

            // Validate as Trio or Run
            string reason;
            if (RulesValidator.TryAsTrio(selectedCards, out reason))
            {
                _bank.Add(new BankGroup(BankGroupType.Trio, selectedCards));
                RemoveSelectedFromHand();
            }
            else
            {
                List<int> resolved;
                if (RulesValidator.TryAsRun(selectedCards, out reason, out resolved))
                {
                    _bank.Add(new BankGroup(BankGroupType.Run, selectedCards));
                    RemoveSelectedFromHand();
                }
                else
                {
                    Debug.LogWarning("❌ No válido para bajar: " + reason);
                    return;
                }
            }

            _selectedHandIndices.Clear();
            RefreshBankUI();
            RefreshHandUI();
        }

        private bool CanDropSelection()
        {
            var selectedCards = GetSelectedCardsSafe(silent:true);
            if (selectedCards.Count < 3) return false;

            string reason;
            if (RulesValidator.TryAsTrio(selectedCards, out reason)) return true;

            List<int> resolved;
            if (RulesValidator.TryAsRun(selectedCards, out reason, out resolved)) return true;

            return false;
        }

        private List<Card> GetSelectedCardsSafe(bool silent=false)
        {
            if (_selectedHandIndices.Count == 0) return new List<Card>();

            var valid = _selectedHandIndices.Where(i => i >= 0 && i < _hand.Count).Distinct().ToList();
            if (valid.Count == 0)
            {
                if (!silent) Debug.LogWarning("No hay selección válida (índices fuera de rango).");
                _selectedHandIndices.Clear();
                return new List<Card>();
            }

            return valid.Select(i => _hand[i]).ToList();
        }

        private void RemoveSelectedFromHand()
        {
            var sorted = _selectedHandIndices.Where(i => i >= 0 && i < _hand.Count).OrderByDescending(i => i).ToList();
            foreach (var i in sorted) _hand.RemoveAt(i);
        }

        private void SmartSort()
        {
            // MVP: helpful for Round 1 (trios) => group by Rank, jokers last
            _hand.Sort((a, b) =>
            {
                if (a.IsJoker && !b.IsJoker) return 1;
                if (!a.IsJoker && b.IsJoker) return -1;
                if (a.IsJoker && b.IsJoker) return 0;

                int r = ((int)a.Rank).CompareTo((int)b.Rank);
                if (r != 0) return r;

                return a.Suit.Value.CompareTo(b.Suit.Value);
            });

            _selectedHandIndices.Clear();
        }

        private void EnsureDeckHasCards()
        {
            if (_deck.Count > 0) return;
            if (_discard.Count <= 1) return;

            var top = _discard[^1];
            var recycle = _discard.GetRange(0, _discard.Count - 1);

            _discard.Clear();
            _discard.Add(top);

            _deck.AddRange(recycle);
            _deck.Shuffle();
        }

        private void RefreshHandUI()
        {
            ClearChildren(handLayout);

            for (int i = 0; i < _hand.Count; i++)
            {
                var c = _hand[i];
                var go = Object.Instantiate(cardPrefab, handLayout);
                var view = go.GetComponent<CardView>();

                bool selected = _selectedHandIndices.Contains(i);
                bool hint = HintForCard(c);

                view.Bind(c, (v) => OnCardClicked(i, v), selected, hint);
            }
        }

        private bool HintForCard(Card c)
        {
            // MVP hint for trios: glow if at least 2 same rank exist
            if (c.IsJoker) return true;
            int same = 0;
            for (int i = 0; i < _hand.Count; i++)
                if (!_hand[i].IsJoker && _hand[i].Rank == c.Rank) same++;
            return same >= 2;
        }

        private void RefreshBankUI()
        {
            ClearChildren(bankLayout);

            for (int g = 0; g < _bank.Count; g++)
            {
                var group = _bank[g];

                var panel = new GameObject($"Group_{g}", typeof(RectTransform), typeof(Image), typeof(VerticalLayoutGroup));
                panel.transform.SetParent(bankLayout, false);

                var img = panel.GetComponent<Image>();
                img.color = new Color(1, 1, 1, 0.10f);

                var vlg = panel.GetComponent<VerticalLayoutGroup>();
                vlg.spacing = 6;
                vlg.childAlignment = TextAnchor.UpperCenter;
                vlg.padding = new RectOffset(10, 10, 10, 10);

                var titleGO = new GameObject("Title", typeof(RectTransform));
                titleGO.transform.SetParent(panel.transform, false);
                var tmp = titleGO.AddComponent<TextMeshProUGUI>();
                tmp.text = (group.Type == BankGroupType.Trio ? "TRÍO" : "ESCALA");
                tmp.fontSize = 20;
                tmp.alignment = TextAlignmentOptions.Center;
                tmp.color = new Color(1, 1, 1, 0.9f);

                var row = new GameObject("Cards", typeof(RectTransform), typeof(HorizontalLayoutGroup));
                row.transform.SetParent(panel.transform, false);
                var h = row.GetComponent<HorizontalLayoutGroup>();
                h.spacing = 8;
                h.childAlignment = TextAnchor.MiddleCenter;

                foreach (var c in group.Cards)
                {
                    var mini = Object.Instantiate(cardPrefab, row.transform);
                    var rt = mini.GetComponent<RectTransform>();
                    if (rt != null) rt.sizeDelta = new Vector2(80, 110);

                    var view = mini.GetComponent<CardView>();
                    view.Bind(c, null, false, false);
                }
            }
        }

        private void RefreshDiscardLabel()
        {
            var tmp = discardButton.GetComponentInChildren<TextMeshProUGUI>(true);
            if (tmp == null) return;

            if (_discard.Count == 0) tmp.text = "DESCARTE";
            else
            {
                var top = _discard[^1];
                tmp.text = top.IsJoker ? "DESCARTE\n(JOKER)" : "DESCARTE\n(" + top.ToString() + ")";
            }
        }

        private static void ClearChildren(Transform t)
        {
            if (t == null) return;
            for (int i = t.childCount - 1; i >= 0; i--)
                Object.DestroyImmediate(t.GetChild(i).gameObject);
        }
    }
}